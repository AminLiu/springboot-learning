## 本示例主要演示自定义HandlerMethodArgumentResolver不生效原因与解法

> 1、不生效原因

是因为springmvc默认就内置一些HandlerMethodArgumentResolver，
比如@RequestBody的解析器RequestResponseBodyMethodProcessor，
默认我们自定义的HandlerMethodArgumentResolver的优先级会低于springmvc内置的HandlerMethodArgumentResolver。
springmvc执行HandlerMethodArgumentResolver，主要是靠聚合器HandlerMethodArgumentResolverComposite中的责任链来执行
而HandlerMethodArgumentResolverComposite会从argumentResolverCache这个缓存根据MethodParameter作为key取出HandlerMethodArgumentResolver
如果我们方法参数中同时存在springmvc内置的HandlerMethodArgumentResolver和自定义的HandlerMethodArgumentResolver，因MethodParameter相同，
则会取出springmvc内置的HandlerMethodArgumentResolver进行执行，而忽略指定以HandlerMethodArgumentResolver

查看具体源码知道怎么回事
org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.afterPropertiesSet
org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.getArgumentResolver

> 解决方案


方案一：调整HandlerMethodArgumentResolver的顺序，可以通过RequestMappingHandlerAdapter进行调整，
不过调整时候有个细节点需注意我们自定义的HandlerMethodArgumentResolver得引入相关内置HandlerMethodArgumentResolver，
不然我们自定义的优先执行了，默认的HandlerMethodArgumentResolver可能就执行不到，这也不是我们想看到的效果，正常是需要一起生效

方案二：采用org.springframework.web.servlet.mvc.method.annotation.RequestBodyAdvice进行实现

方案三：通过AOP进行实现

方案四：拦截器

方案五：过滤器
